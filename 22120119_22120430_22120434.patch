diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..95832f5
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,7 @@
+{
+    "files.associations": {
+        "param.h": "c",
+        "proc.h": "c",
+        "types.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/22120119_22120430_22120434.patch b/22120119_22120430_22120434.patch
index 4aa3347..e69de29 100644
--- a/22120119_22120430_22120434.patch
+++ b/22120119_22120430_22120434.patch
@@ -1,329 +0,0 @@
-diff --git a/xv6-labs-2024/Makefile b/xv6-labs-2024/Makefile
-index 74e454f..91f76f9 100644
---- a/xv6-labs-2024/Makefile
-+++ b/xv6-labs-2024/Makefile
-@@ -194,6 +194,10 @@ UPROGS=\
- 	$U/_grind\
- 	$U/_wc\
- 	$U/_zombie\
-+	$U/_pingpong\
-+	$U/_find\
-+	$U/_primes\
-+	$U/_xargs\
- 
- 
- 
-diff --git a/xv6-labs-2024/user/find.c b/xv6-labs-2024/user/find.c
-new file mode 100644
-index 0000000..8c01f87
---- /dev/null
-+++ b/xv6-labs-2024/user/find.c
-@@ -0,0 +1,105 @@
-+#include "kernel/types.h"
-+#include "kernel/stat.h"
-+#include "user/user.h"
-+#include "kernel/fs.h"
-+#include "kernel/fcntl.h" 
-+                                                                                          // hàm fmt để trả về tên thư mục hoặc tệp từ đường dẫn path
-+char *fmtname(char *path)
-+{
-+  static char buf[DIRSIZ + 1];
-+  char *p;
-+
-+                                                                                              // Tìm kí tự '/' cuối cùng
-+  for (p = path + strlen(path); p >= path && *p != '/'; p--)
-+    ;
-+  p++;
-+
-+                                                                                       // Trả về tên của  của tệp hoặc thư mục đang đọc
-+  if (strlen(p) >= DIRSIZ)                                                              // kiểm tra chiều dài có vượt quá giới hạn không
-+    return p;
-+  memmove(buf, p, strlen(p));                                                         // copy tên thư mục hoặc tệp đang đọc vào buf
-+  buf[strlen(p)] = '\0';                                                              // chuyển kí tự cuối cùng về '\0'
-+  return buf;                                                                         // trả về buf
-+} 
-+                                                                                          // viết hàm find
-+void find(char *path, char *findname)
-+{
-+  char buf[512], *p;                                                              // buf là mảng kí tự dùng để lưu đường dẫn tạm. p là con trỏ trỏ tới phần tử của mảng đó
-+  int fd;                                                                             // lưu file descriptor
-+  struct dirent de;                                                                  // lưu phần tử đại diện cho 1 entry
-+  struct stat st;                                                                    // lưu phần tử chứa thông ti của tệp
-+
-+  // lấy fd từ đường dẫn và kiểm tra
-+  if ((fd = open(path, O_RDONLY)) < 0)
-+  {
-+    fprintf(2, "ls: cannot open %s\n", path);
-+    return;
-+  }
-+
-+                                                                                      // lấy st từ fd và kiểm tra
-+  if (fstat(fd, &st) < 0)
-+  {
-+    fprintf(2, "ls: cannot stat %s\n", path);
-+    close(fd);
-+    return;
-+  }
-+                                                                                        // tùy loại tệp mà ta xử lý khác nhau
-+  switch (st.type)
-+  {
-+  case T_DEVICE:
-+  case T_FILE:                                                                          // nếu là file thì in ra đường dẫn luôn
-+
-+    if (strcmp(fmtname(path), findname) == 0)                                           // kiểm tra tên file đang đọc có trùng với tên file đang kiếm không
-+      printf("%s\n", path);
-+    break;
-+
-+  case T_DIR:                                                                                 // nếu là thư mục thì ta phải vừa tìm vừa truy xuất vào thư mục con ( dùng đệ quy )
-+    if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf)
-+    {                                                                                       // kiểm tra chiều dài
-+      printf("ls: path too long\n");
-+      break;
-+    }
-+
-+    while (read(fd, &de, sizeof(de)) == sizeof(de))
-+    {                                                                                        // đọc các thư mục hoặc tệp ở thư mục hiện tại
-+
-+      if (strcmp(".", fmtname(de.name)) == 0 || strcmp("..", fmtname(de.name)) == 0)
-+      {                                                                                     // bỏ qua thư mục . và  ..
-+        continue;
-+      }
-+
-+      if (de.inum == 0)                                                                          // kiểm tra thông tin của entry
-+        continue;
-+                                                                                                   // tạo đường dẫn đến các thư mục, tệp con
-+      strcpy(buf, path);
-+      p = buf + strlen(buf);
-+      *p++ = '/';
-+      memmove(p, de.name, DIRSIZ);
-+      p[DIRSIZ] = 0;
-+                                                                                                   // Kiểm tra xem có mở được không
-+      if (stat(buf, &st) < 0)
-+      {
-+        printf("ls: cannot stat %s\n", buf);
-+        continue;
-+      }
-+
-+                                                                                                      // Đệ quy vào tệp hoặc thư mục, nếu là tệp thì phía trên đã xử lý, nếu là thư mục thì sẽ đệ quy lần nữa
-+      find(buf, findname);
-+    }
-+    break;
-+  }
-+  close(fd);
-+}
-+
-+int main(int argc, char *argv[])
-+{
-+  // Kiểm tra số lượng tham số
-+  if (argc < 3)
-+  {
-+    printf("Usage: %s <path> <name_to_find>\n", argv[0]);
-+    exit(0);
-+  }
-+
-+  find(argv[1], argv[2]);
-+  exit(0);
-+}
-\ No newline at end of file
-diff --git a/xv6-labs-2024/user/pingpong.c b/xv6-labs-2024/user/pingpong.c
-new file mode 100644
-index 0000000..2ff6e03
---- /dev/null
-+++ b/xv6-labs-2024/user/pingpong.c
-@@ -0,0 +1,29 @@
-+#include "kernel/types.h"  // Khai báo các kiểu dữ liệu cơ bản (int, uint, ...)
-+#include "kernel/stat.h"   // Khai báo các hàm liên quan đến file stat
-+#include "user/user.h"     // Khai báo các hàm hệ thống như fork, pipe, read, write
-+
-+int main(int argc, char *argv[])
-+{
-+    int p[2];  // tạo 2 file descriptor p[0] để, đọc p[1] để ghi
-+    char recv_buf[5]; // tạo chuỗi chứa dữ liệu nhận được
-+
-+    pipe(p); // tạo đường ống giữa 2 tiến trình
-+
-+    if (fork() == 0) {  // gọi fork() để tạo tiến trình con trong tiến trình cha đang chạy, nó sẽ trả về khác 0 ở tiến trình cha và bằng 0 ở tiến trình con
-+        read(p[0], recv_buf, 5);  // đọc dữ liệu từ cha
-+        printf("%d: received %s\n", getpid(), recv_buf); // in ra màn hình
-+        close(p[0]);  // đóng đầu đọc
-+
-+        write(p[1], "pong", 5); // ghi dữ liệu vào pipe
-+        close(p[1]); // đóng đầu ghi
-+
-+    } else {  // Tiến trình cha
-+        write(p[1], "ping", 5);  // viết vào pipe
-+        close(p[1]);    // đóng đầu viết
-+             wait(0);  // chờ tiến trình con chạy xong
-+        read(p[0], recv_buf, 5);  // đọc dữ liệu từ tiến trình con
-+        printf("%d: received %s\n", getpid(), recv_buf); // in ra màn hình
-+        close(p[0]); // đóng đầu đọc
-+    }
-+    exit(0);
-+}
-\ No newline at end of file
-diff --git a/xv6-labs-2024/user/primes.c b/xv6-labs-2024/user/primes.c
-new file mode 100644
-index 0000000..2dbec89
---- /dev/null
-+++ b/xv6-labs-2024/user/primes.c
-@@ -0,0 +1,65 @@
-+#include "kernel/types.h"
-+#include "kernel/stat.h"
-+#include "user/user.h"
-+
-+void primes(int left_pipe[2]) __attribute__((noreturn));
-+
-+void primes(int left_pipe[2]) {
-+    int p, num;
-+    int right_pipe[2];
-+    close(left_pipe[1]);
-+
-+    if (read(left_pipe[0], &p, sizeof(p)) == 0) {
-+        close(left_pipe[0]);
-+        exit(0);
-+    }
-+    printf("prime %d\n", p);
-+
-+    if (pipe(right_pipe) < 0) {
-+        printf("pipe failed\n");
-+        exit(1);
-+    }
-+
-+    if (fork() == 0) {
-+        close(left_pipe[0]); 
-+        primes(right_pipe);   
-+    } else {
-+        close(right_pipe[0]); 
-+        while (read(left_pipe[0], &num, sizeof(num)) > 0) {
-+           
-+            if (num % p != 0) {
-+                write(right_pipe[1], &num, sizeof(num));
-+            }
-+        }
-+        close(left_pipe[0]);  
-+        close(right_pipe[1]);
-+        wait(0);              
-+        exit(0);
-+    }
-+}
-+
-+int main() {
-+    int i;
-+    int left_pipe[2];
-+
-+    if (pipe(left_pipe) < 0) {
-+        printf("pipe failed\n");
-+        exit(1);
-+    }
-+
-+    if (fork() == 0) {
-+        primes(left_pipe);
-+    } else {
-+
-+        close(left_pipe[0]);
-+        for (i = 2; i <= 280; i++) {
-+            if (write(left_pipe[1], &i, sizeof(i)) < 0) {
-+                printf("write failed\n");
-+                exit(1);
-+            }
-+        }
-+        close(left_pipe[1]); 
-+        wait(0);           
-+        exit(0);
-+    }
-+}
-diff --git a/xv6-labs-2024/user/xargs.c b/xv6-labs-2024/user/xargs.c
-new file mode 100644
-index 0000000..233efe6
---- /dev/null
-+++ b/xv6-labs-2024/user/xargs.c
-@@ -0,0 +1,88 @@
-+#include "kernel/types.h"
-+#include "user/user.h"
-+#include "kernel/param.h"
-+int main(int argc,char *argv[])
-+{
-+    int b_argc=1;
-+    char * b_argv[MAXARG];
-+    int i=0;
-+    char buf[512];
-+    char *start;
-+    char *end;
-+    if(strcmp(argv[1],"-n")==0)
-+    {
-+        i=3;
-+    }
-+    else{
-+        i=1;
-+    }
-+    b_argv[0]=argv[i];
-+    i++;
-+    for(;i<argc;i++)
-+    {
-+        b_argv[b_argc++]=argv[i];
-+    }
-+    start=end=buf;
-+    while(read(0,end,sizeof(char)))
-+    {
-+        if(*end=='\n')
-+        {
-+            if(b_argc==MAXARG-1)
-+            {
-+                fprintf(2,"too many arguments\n");
-+            }
-+            else{
-+                *end='\0';
-+                b_argv[b_argc++]=start;
-+                if(fork()==0)
-+                {
-+                    exec(b_argv[0],b_argv);
-+                    fprintf(2, "exec failed\n");
-+                    exit(1);
-+                }
-+                else
-+                { 
-+                    wait(0);
-+                }
-+            }
-+            start=end=buf;
-+            b_argc=argc-1;
-+        }
-+        else if(*end==' ')
-+        {
-+            if(b_argc==MAXARG-1)
-+            {
-+                fprintf(2,"too many arguments\n");
-+                while(*end!='\n')
-+                {
-+                    read(0,end,sizeof(char));
-+                }
-+                end=start=buf;
-+                b_argc=argc-1;
-+            }
-+            else
-+            {
-+                *end='\0';
-+                b_argv[b_argc++]=start;
-+                end++;
-+                start=end;
-+            }
-+        }
-+        else
-+        {
-+            end++;
-+            if(end>=buf+sizeof(buf))
-+            {
-+                end--;
-+                while(*end!='\n')
-+                {
-+                    read(0,end,sizeof(char));
-+                }
-+                fprintf(2,"too many inputs\n");
-+                end=start=buf;
-+                b_argc=argc-1;
-+            }
-+        }
-+    }
-+    exit(0);
-+}
-\ No newline at end of file
diff --git a/Makefile b/Makefile
index 91f76f9..73b899e 100644
--- a/Makefile
+++ b/Makefile
@@ -196,8 +196,12 @@ UPROGS=\
 	$U/_zombie\
 	$U/_pingpong\
 	$U/_find\
-	$U/_primes\
 	$U/_xargs\
+	$U/_primes\
+	$U/_trace\
+	$U/_sysinfotest\
+
+
 
 
 
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 0699e7e..eb708e2 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -80,3 +80,16 @@ kalloc(void)
     memset((char*)r, 5, PGSIZE); // fill with junk
   return (void*)r;
 }
+
+uint64 freemem() {
+    struct run *r;
+    uint64 free_memory = 0;
+
+    acquire(&kmem.lock);
+    for (r = kmem.freelist; r; r = r->next) {
+        free_memory += PGSIZE; 
+    }
+    release(&kmem.lock);
+
+    return free_memory;
+}
\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index 130d9ce..43d8b2d 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -283,10 +283,14 @@ fork(void)
   struct proc *np;
   struct proc *p = myproc();
 
+
+
   // Allocate process.
   if((np = allocproc()) == 0){
     return -1;
   }
+   // Copy mask
+ np->mask = p->mask;
 
   // Copy user memory from parent to child.
   if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
@@ -321,7 +325,7 @@ fork(void)
   acquire(&np->lock);
   np->state = RUNNABLE;
   release(&np->lock);
-
+ 
   return pid;
 }
 
@@ -693,3 +697,18 @@ procdump(void)
     printf("\n");
   }
 }
+
+uint64 getnproc() {
+  uint64 count = 0;
+  struct proc *p;
+  for (p = proc; p < &proc[NPROC]; p++) {
+    acquire(&p->lock);
+    if (p->state != UNUSED) {
+      count++;
+    }
+    release(&p->lock);
+  }
+  return count;
+}
+
+
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..fbdcad2 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -104,4 +104,5 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int mask;
 };
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..797410a 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,8 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_trace(void);
+extern uint64 sys_sysinfo(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,8 +128,10 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_trace]   sys_trace,
+[SYS_sysinfo] sys_sysinfo
 };
-
+static char *syscall_name[]={"","fork","exit","wait","pipe","read","kill","exec","fstat","chdir","dup","getpid","sbrk","sleep","uptime","open","write","mknod","unlink","link","mkdir","close","trace","sysinfo"};
 void
 syscall(void)
 {
@@ -139,6 +143,13 @@ syscall(void)
     // Use num to lookup the system call function for num, call it,
     // and store its return value in p->trapframe->a0
     p->trapframe->a0 = syscalls[num]();
+
+    if((p->mask >>num ) & 1){
+    
+     printf("%d: syscall %s -> %ld\n",p->pid,syscall_name[num],p->trapframe->a0);
+
+    }
+
   } else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..e153363 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_trace  22
+#define SYS_sysinfo 23
\ No newline at end of file
diff --git a/kernel/sysinfo.h b/kernel/sysinfo.h
new file mode 100644
index 0000000..7b2773c
--- /dev/null
+++ b/kernel/sysinfo.h
@@ -0,0 +1,9 @@
+#include "types.h"
+
+struct sysinfo {
+    uint64 freemem;
+    uint64 nproc;
+};
+
+uint64 freemem(void);
+uint64 getnproc(void);
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..6809aa0 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -1,3 +1,4 @@
+#include "sysinfo.h"
 #include "types.h"
 #include "riscv.h"
 #include "defs.h"
@@ -91,3 +92,24 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+
+uint64 
+sys_trace(void){
+  int n ;
+  argint(0,&n);
+  myproc()->mask =n;
+   return 0;
+}
+
+uint64
+sys_sysinfo(void){
+  struct sysinfo kinfo;
+  uint64 info;
+  argaddr(0, &info);
+  kinfo.freemem = freemem();
+  kinfo.nproc = getnproc();
+  if (copyout(myproc()->pagetable, info, (char*)&kinfo, sizeof(struct sysinfo)) < 0)
+    return -1;
+  return 0;
+}
\ No newline at end of file
diff --git a/user/sysinfotest.c b/user/sysinfotest.c
new file mode 100644
index 0000000..ab80e8f
--- /dev/null
+++ b/user/sysinfotest.c
@@ -0,0 +1,29 @@
+#include "kernel/types.h"
+#include "kernel/sysinfo.h"
+#include "user/user.h"
+#include "kernel/stat.h"
+
+void sysinfotest() {
+    printf( "sysinfotest: Starting tests\n");
+    struct sysinfo info;
+
+    if (sysinfo(&info) < 0) {
+        printf("sysinfotest: sysinfo failed\n");
+        exit(1);
+    }
+    if (info.freemem == 0) {
+        printf("sysinfotest: freemem is 0\n");
+        exit(1);
+    }
+    if (info.nproc == 0) {
+        printf("sysinfotest: nproc is 0\n");
+        exit(1);
+    }
+    printf("sysinfotest: OK\n");
+    exit(0);
+}
+
+int main(int argc, char *argv[]) {
+    sysinfotest();
+    return 0;
+}
diff --git a/user/trace.c b/user/trace.c
new file mode 100644
index 0000000..8be5476
--- /dev/null
+++ b/user/trace.c
@@ -0,0 +1,45 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h" 
+#include "kernel/param.h"
+#define MAXSTRLEN 100
+int main(int argc, char *argv[])
+{
+
+    if(!strcmp(argv[0],"trace")){
+    
+
+      
+      int n;
+      n = atoi(argv[1]);
+      trace(n);
+
+      char *b_argv[MAXARG];  
+      char b_strings[MAXARG][MAXSTRLEN];  
+
+
+      int b_argc = 0;
+
+      for (int i = 2; i < argc; i++) {
+
+       strcpy(b_strings[b_argc], argv[i]);
+       b_strings[b_argc][MAXSTRLEN - 1] = '\0';  
+
+ 
+       b_argv[b_argc] = b_strings[b_argc];
+       b_argc++;
+}
+
+       b_argv[b_argc] = 0;  
+       exec(b_argv[0],b_argv);
+
+    } else{
+      trace(0);
+      exec(argv[0],argv);
+    }
+    exit(0);
+}
+
+                            
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index f16fe27..889c58e 100644
--- a/user/user.h
+++ b/user/user.h
@@ -22,6 +22,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int trace(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -37,6 +38,8 @@ void* memset(void*, int, uint);
 int atoi(const char*);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
+struct sysinfo;
+int sysinfo(struct sysinfo *info);
 
 // umalloc.c
 void* malloc(uint);
diff --git a/user/usertests.c b/user/usertests.c
index 28b53f9..53808cf 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -1020,11 +1020,10 @@ forkforkfork(char *s)
 
     exit(0);
   }
-
-  sleep(20); // two seconds
+ sleep(30); // two seconds
   close(open("stopforking", O_CREATE|O_RDWR));
   wait(0);
-  sleep(10); // one second
+ sleep(10); // one second
 }
 
 // regression test. does reparent() violate the parent-then-child
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..353a1f8 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");
+entry("sysinfo");
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
index 233efe6..37fa9f9 100644
--- a/user/xargs.c
+++ b/user/xargs.c
@@ -1,88 +1,88 @@
-#include "kernel/types.h"
-#include "user/user.h"
-#include "kernel/param.h"
-int main(int argc,char *argv[])
-{
-    int b_argc=1;
-    char * b_argv[MAXARG];
-    int i=0;
-    char buf[512];
-    char *start;
-    char *end;
-    if(strcmp(argv[1],"-n")==0)
-    {
-        i=3;
-    }
-    else{
-        i=1;
-    }
-    b_argv[0]=argv[i];
-    i++;
-    for(;i<argc;i++)
-    {
-        b_argv[b_argc++]=argv[i];
-    }
-    start=end=buf;
-    while(read(0,end,sizeof(char)))
-    {
-        if(*end=='\n')
-        {
-            if(b_argc==MAXARG-1)
-            {
-                fprintf(2,"too many arguments\n");
-            }
-            else{
-                *end='\0';
-                b_argv[b_argc++]=start;
-                if(fork()==0)
-                {
-                    exec(b_argv[0],b_argv);
-                    fprintf(2, "exec failed\n");
-                    exit(1);
-                }
-                else
-                { 
-                    wait(0);
-                }
-            }
-            start=end=buf;
-            b_argc=argc-1;
-        }
-        else if(*end==' ')
-        {
-            if(b_argc==MAXARG-1)
-            {
-                fprintf(2,"too many arguments\n");
-                while(*end!='\n')
-                {
-                    read(0,end,sizeof(char));
-                }
-                end=start=buf;
-                b_argc=argc-1;
-            }
-            else
-            {
-                *end='\0';
-                b_argv[b_argc++]=start;
-                end++;
-                start=end;
-            }
-        }
-        else
-        {
-            end++;
-            if(end>=buf+sizeof(buf))
-            {
-                end--;
-                while(*end!='\n')
-                {
-                    read(0,end,sizeof(char));
-                }
-                fprintf(2,"too many inputs\n");
-                end=start=buf;
-                b_argc=argc-1;
-            }
-        }
-    }
-    exit(0);
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/param.h"
+int main(int argc,char *argv[])
+{
+    int b_argc=1;
+    char * b_argv[MAXARG];
+    int i=0;
+    char buf[512];
+    char *start;
+    char *end;
+    if(strcmp(argv[1],"-n")==0)
+    {
+        i=3;
+    }
+    else{
+        i=1;
+    }
+    b_argv[0]=argv[i];
+    i++;
+    for(;i<argc;i++)
+    {
+        b_argv[b_argc++]=argv[i];
+    }
+    start=end=buf;
+    while(read(0,end,sizeof(char)))
+    {
+        if(*end=='\n')
+        {
+            if(b_argc==MAXARG-1)
+            {
+                fprintf(2,"too many arguments\n");
+            }
+            else{
+                *end='\0';
+                b_argv[b_argc++]=start;
+                if(fork()==0)
+                {
+                    exec(b_argv[0],b_argv);
+                    fprintf(2, "exec failed\n");
+                    exit(1);
+                }
+                else
+                { 
+                    wait(0);
+                }
+            }
+            start=end=buf;
+            b_argc=argc-1;
+        }
+        else if(*end==' ')
+        {
+            if(b_argc==MAXARG-1)
+            {
+                fprintf(2,"too many arguments\n");
+                while(*end!='\n')
+                {
+                    read(0,end,sizeof(char));
+                }
+                end=start=buf;
+                b_argc=argc-1;
+            }
+            else
+            {
+                *end='\0';
+                b_argv[b_argc++]=start;
+                end++;
+                start=end;
+            }
+        }
+        else
+        {
+            end++;
+            if(end>=buf+sizeof(buf))
+            {
+                end--;
+                while(*end!='\n')
+                {
+                    read(0,end,sizeof(char));
+                }
+                fprintf(2,"too many inputs\n");
+                end=start=buf;
+                b_argc=argc-1;
+            }
+        }
+    }
+    exit(0);
 }
\ No newline at end of file
